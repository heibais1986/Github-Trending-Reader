"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.FileUtil=void 0;const crypto_1=require("crypto"),fs_1=__importDefault(require("fs")),promises_1=__importDefault(require("fs/promises")),node_fs_1=require("node:fs"),path_1=__importDefault(require("path")),promises_2=require("stream/promises"),hvigor_1=require("@ohos/hvigor"),task_util_1=require("@ohos/hvigor/src/base/util/task-util"),fs_extra_1=__importDefault(require("fs-extra")),glob_1=require("glob"),common_const_js_1=require("../const/common-const.js"),dependenct_param_validate_js_1=require("../validate/dependenct-param-validate.js"),json_util_js_1=require("./json-util.js"),oh_package_loader_js_1=require("./loader/file/oh-package-loader.js"),ohos_logger_js_1=require("./log/ohos-logger.js");class FileUtil{static async linkFile(t,e,a=!1){await FileUtil.exists(t)||this._log.printErrorExit("CANNOT_FIND_SO_SOURCE",[t],[[t]]);const s=await promises_1.default.lstat(t);if(s.isDirectory())return void this._log.debug(`Skip copying ${t}, as it is a folder.`);if(!fs_1.default.existsSync(t))return void this._log.debug(`Non-existent file or symbolic link ${t}.`);const i=a&&s.isSymbolicLink()?path_1.default.resolve(path_1.default.dirname(t),await promises_1.default.readlink(t)):t;await fs_extra_1.default.ensureDir(path_1.default.dirname(e));try{if(await promises_1.default.access(t,fs_1.default.constants.R_OK),await FileUtil.exists(e)&&await promises_1.default.unlink(e),await promises_1.default.link(t,e),this._log.debug(`Link ${i} to ${e} successfully.`),a&&s.isSymbolicLink()){const s=path_1.default.resolve(path_1.default.dirname(e),await promises_1.default.readlink(t));await this.linkFile(i,s,a)}}catch(a){this._log.debug(`Hard link from ${t} to ${e} failed. Do copy instead.`),await promises_1.default.copyFile(i,e)}}static async exists(t){try{return await promises_1.default.lstat(t),!0}catch(t){return!1}}static isDirectory(...t){return fs_extra_1.default.statSync(path_1.default.resolve(...t)).isDirectory()}static checkDirWithoutDelete(...t){const e=path_1.default.resolve(...t);fs_extra_1.default.existsSync(e)||fs_extra_1.default.mkdirSync(e,{recursive:!0})}static checkFile(...t){const e=path_1.default.resolve(...t);fs_extra_1.default.existsSync(e)||FileUtil.makeFile(e),fs_extra_1.default.removeSync(e),FileUtil.makeFile(e)}static makeFile(t,e=""){fs_extra_1.default.writeFileSync(t,e)}static deleteFile(t){try{fs_extra_1.default.existsSync(t)&&fs_extra_1.default.removeSync(t)}catch(e){this._log.printErrorExit("DELETE_FILE_ERROR",[t])}}static readFile(t){try{if(!fs_extra_1.default.existsSync(t))return;return fs_extra_1.default.readFileSync(t,{encoding:"utf-8"})}catch(e){return void this._log.error(`Please check file at ${t}.`)}}static checkPathLength(t){const e=(0,hvigor_1.maxPathLength)();t.length>e&&this._log.printErrorExit("FILE_PATH_EXCEED_LIMITATION",[`${e}`])}static async hashEntry(t,e="**/*"){const a=new Map,s=glob_1.glob.sync(e,{nodir:!0,absolute:!0,cwd:t,follow:!1});for(const t of s){const e=await this.pipelineAsync(t);a.set(t,e)}return a}static async pipelineAsync(t){var e;return(null===(e=null===hvigor_1.hvigorCore||void 0===hvigor_1.hvigorCore?void 0:hvigor_1.hvigorCore.getParameter())||void 0===e?void 0:e.getProperty(common_const_js_1.CommonConst.OHOS_PROCESSLIB_OPTIMIZATION))?(this._log.debug(`Check size & timestamp for ${t}`),this.hashStats(t)):(this._log.debug(`Check content hash for ${t}`),await this.hashContent(t))}static async hashContent(t){if(!fs_extra_1.default.existsSync(t))throw new Error(`File "${t}" does not exist`);const e=(0,crypto_1.createHash)("md5");return await(0,promises_2.pipeline)((0,node_fs_1.createReadStream)(t),e),e.digest("hex")}static hashStats(t){if(!fs_extra_1.default.existsSync(t))throw new Error(`File "${t}" does not exist`);const e=(0,crypto_1.createHash)("md5"),a=fs_1.default.statSync(t);return e.update(a.size.toString()+a.mtimeMs),e.digest("hex")}static convertToAbsolutePath(t,e){return path_1.default.isAbsolute(t)?t:path_1.default.resolve(e,t)}static convertToAbsolutePaths(t,e){return t.map(t=>FileUtil.convertToAbsolutePath(t,e))}static isSubDir(t,e){const a=path_1.default.relative(t,e);return a&&!a.startsWith("..")&&!path_1.default.isAbsolute(a)}static fileExists(t){return fs_1.default.existsSync(t)&&fs_1.default.realpathSync.native(t)===t}static matchingFile(t,e=!1){return!!glob_1.glob.sync(t,{nocase:e}).length}static copySpecialFileToTempDir(t,e){fs_extra_1.default.readdirSync(t).forEach(a=>{if(this.checkSpecialFile(a)){const s=path_1.default.resolve(t,a);fs_extra_1.default.statSync(s).isFile()&&fs_extra_1.default.copySync(s,path_1.default.resolve(e,a))}})}static disposalPackingOptionAsset(t,e,a){var s,i;((null===(s=null==e?void 0:e.include)||void 0===s?void 0:s.length)||(null===(i=null==e?void 0:e.exclude)||void 0===i?void 0:i.length))&&(this.disposalPackingOptInclude(e.include,t,a),this.disposalPackingOptExclude(e.exclude,a))}static disposalPackingOptInclude(t,e,a){if(!(null==t?void 0:t.length))return;const s=["node_modules/**","oh_modules/**",".preview/**","build/**",".cxx/**",".test/**"],i=path_1.default.resolve(e),r=new Set;t.forEach(t=>{const a=glob_1.glob.sync(t,{cwd:e,ignore:s});(null==a?void 0:a.length)&&a.forEach(t=>{r.add(t)})}),r.forEach(t=>{const s=path_1.default.resolve(e,t);s.startsWith(i)&&fs_extra_1.default.existsSync(s)&&fs_extra_1.default.copySync(s,path_1.default.resolve(a,t))})}static disposalPackingOptExclude(t,e){if(!(null==t?void 0:t.length))return;const a=["oh-package.json5","ResourceTable.txt","Index.d.ets","ets/**","src/main/module.json"],s=path_1.default.resolve(e);t.forEach(t=>{const i=glob_1.glob.sync(t,{cwd:e,ignore:a});(null==i?void 0:i.length)&&i.forEach(t=>{const a=path_1.default.resolve(e,t);a.startsWith(s)&&fs_extra_1.default.existsSync(a)&&fs_extra_1.default.removeSync(a)})})}static async readDirFileNames(t){const e=new Set;return await async function t(a){try{const s=await fs_extra_1.default.readdir(a,{withFileTypes:!0});for(const i of s){const s=path_1.default.join(a,i.name);i.isDirectory()?await t(s):e.add(i.name)}}catch(t){}}(t),e}static addParamToOhPack(t,e,a,s,i,r){const o=t?common_const_js_1.CommonConst.OH_PACKAGE_JSON5:common_const_js_1.CommonConst.PACKAGE_JSON,l=oh_package_loader_js_1.ohPackageLoader.getNodeOhPackagePath(path_1.default.resolve(e,o));let n=(0,json_util_js_1.getJson5Obj)(l);n.metadata?Object.assign(n.metadata,a):Object.assign(n,{metadata:a}),n=FileUtil.mergeExtraParamsToOhPack(n,s,i,r),fs_extra_1.default.writeJSONSync(l,n)}static mergeExtraParamsToOhPack(t,e,a,s){return t={...t,...e,nativeComponents:(t.nativeComponents||[]).concat(e.nativeComponents||[])},e.nativeComponents||delete t.nativeComponents,t.nativeComponents&&(t.nativeComponents=t.nativeComponents.filter(t=>s.has(t.name))),a===(0,task_util_1.getAlignTarget)()&&(t.version+=`+${(0,task_util_1.getAlignTarget)()}`),t}static checkSpecialFile(t){const e=t.toLowerCase(),a=e.split(".")[0];return-1!==["readme.opensource"].indexOf(e)||-1!==["license"].indexOf(a)||/^(changelog|readme)([-_](cn|en))?\.md$/i.test(e)}static uniqueFileName(t,e){const a=new Map;if(t.forEach(t=>{a.set(t,1)}),a.has(e)){let t=a.get(e);for(;a.has(this.addSuffix(e,t));)t++;a.set(e,t+1);const s=this.addSuffix(e,t);return a.set(s,1),s}return a.set(e,1),e}static addSuffix(t,e){return`${t}${e}`}static traverseFileFolder(t){const e=[];if(!fs_extra_1.default.statSync(t).isDirectory()||!fs_extra_1.default.existsSync(t))return[];return fs_extra_1.default.readdirSync(t).forEach(a=>{const s=path_1.default.join(t,a),i=fs_extra_1.default.statSync(s);i.isDirectory()?this.traverseFileFolder(s):i.isFile()&&e.push(a.split(".")[0])}),e}static getAllFilesFromFolder(t){const e=[];if(!fs_extra_1.default.existsSync(t)||!fs_extra_1.default.statSync(t).isDirectory())return[];return fs_extra_1.default.readdirSync(t).forEach(a=>{const s=path_1.default.join(t,a),i=fs_extra_1.default.statSync(s);i.isDirectory()?e.push(...this.getAllFilesFromFolder(s)):i.isFile()&&e.push(s)}),e}static getFileSuffix(t){const e=path_1.default.parse(t).base;return""===e||-1===e.indexOf(".")?e:e.substring(e.lastIndexOf(".")+1)}static normalizePathSeparator(t){return t.replace(/\\\\/g,"/").replace(/\\/g,"/").replace(/\/:/g,":")}static resolveJsonObjWithoutParam(t,e,a,s,i){const r=[];for(const o in t)if(!s||s.includes(o))if("object"==typeof t[o]&&null!==t[o]){const s=this.resolveJsonObjWithoutParam(t[o],e,a,void 0,i);r.push(...s)}else if("string"==typeof t[o]){const s=FileUtil.extractValue(t[o],e,a,i,o);t[o]=s.value,s.localDepArr&&r.push(...s.localDepArr)}return this._log.debug(`jsonObjWithoutParam ${JSON.stringify(t)} at ${a.parameterFilePath}`),r}static extractValue(t,e,a,s,i){const r=t.match(common_const_js_1.ParameterizationConst.REGEX);if(!r)return{value:t};e||this._log.printErrorExit("PARAMETER_FILE_KEY_ERROR",[t,a.parameterFilePath]);const o=r[1].split(".");return(0,dependenct_param_validate_js_1.matchValueWithParameterizationKey)({keys:o,parameterFileJson:e,pathParamsObj:a,dependencyName:i,ohPackageInfoGetter:s})}static extracted(t,e,a,s){return FileUtil.extractValue(t,e,a,void 0,s).value}static copyDir(t,e){const a=fs_extra_1.default.readdirSync(t,{withFileTypes:!0});fs_extra_1.default.mkdirsSync(e);for(const s of a){const a=path_1.default.join(t,s.name),i=path_1.default.join(e,s.name);s.isDirectory()?this.copyDir(a,i):fs_extra_1.default.copyFileSync(a,i)}}static async isEmptyDir(t){if(!fs_extra_1.default.existsSync(t))return!0;try{return 0===(await fs_extra_1.default.readdir(t)).length}catch(e){return this._log.debug(`failed to readdir ${t}`),!1}}}exports.FileUtil=FileUtil,FileUtil._log=ohos_logger_js_1.OhosLogger.getLogger("File");