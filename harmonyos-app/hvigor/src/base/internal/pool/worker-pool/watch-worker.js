"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.normalWorker=exports.watchWorker=void 0;const cluster_1=__importDefault(require("cluster")),worker_threads_1=require("worker_threads"),hook_const_js_1=require("../../../../common/const/hook-const.js"),noop_js_1=require("../../../../common/util/noop.js"),build_event_js_1=require("../../../common/daemon-protocol/build-event.js"),worker_process_event_id_js_1=require("../../../daemon/cluster/worker-process-event-id.js"),hvigor_log_js_1=require("../../../log/hvigor-log.js"),duration_event_js_1=require("../../../metrics/event/duration-event.js"),log_event_js_1=require("../../../metrics/event/log-event.js"),hvigor_lifecycle_hook_js_1=require("../../lifecycle/hook/hvigor-lifecycle-hook.js"),constant_js_1=require("../constant/constant.js"),log=hvigor_log_js_1.HvigorLogger.getLogger("daemon");class WorkerItem{constructor(e,r){this.worker=e,this.hasCustomTerminate=r}}const genPromiseAndTriggers=(e,r)=>{let o=noop_js_1.noop,t=noop_js_1.noop;const n=new Promise((n,s)=>{o=o=>{e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process.hrtime.bigint())]),s(o)},t=o=>{e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process.hrtime.bigint())]),n(o)}});return{reject:o,resolve:t,promise:n}};async function handleResponse(e,r,o,t,n,s){if(e.event!==constant_js_1.PoolConstant.WORK_DONE){if(e.event===constant_js_1.PoolConstant.WORK_ERROR){null==s||s.stop(duration_event_js_1.DurationEventState.FAILED),null==s||s.setLog(null==s?void 0:s.getName(),log_event_js_1.MetricLogType.ERROR),await n(e.returnVal);const a=e.error,i=`${r.getName()} ${t?"watch":"normal"} work[${o}] failed.`;throw log.debug(i),new Error(a||i)}throw new Error(`Unknown worker event: ${e}.`)}null==s||s.stop(duration_event_js_1.DurationEventState.SUCCESS),null==s||s.setLog(null==s?void 0:s.getName(),log_event_js_1.MetricLogType.INFO),await n(e.returnVal)}class WorkerCountManager{static allocateWorkerId(){return this.cnt++}static reset(){this.cnt=1}}WorkerCountManager.cnt=1;class WatchWorker{constructor(){this.workerMap=new Map,this.addListenersOnSessionManager()}getWorker(e){var r;return null===(r=this.workerMap.get(e))||void 0===r?void 0:r.worker}sendCompileMsgToWorker(){this.workerMap.forEach((e,r)=>{e.worker.postMessage({event:"HOT_COMPILE"})})}createWorker(e,r,o,t,n){const s=Number(process.hrtime.bigint()),a=new worker_threads_1.Worker(r,n),i=WorkerCountManager.allocateWorkerId();this.workerMap.set(i,new WorkerItem(a,o));const l=e.addSubDurationEvent(i.toString()).start();null==l||l.setTid(`Worker${i}`),cluster_1.default.isWorker&&process.send({type:build_event_js_1.WatchEvent.NEW_WATCH_WORKER,workerId:i});const{promise:_,resolve:c,reject:u}=genPromiseAndTriggers(e,s);return e.pendingPromises.add(_),this.createWorkerOnMessageListener(a,c,u,e,i,t,l),this.createWorkerOnErrorListener(a,u,e,i),i.toString()}createWorkerOnMessageListener(e,r,o,t,n,s,a){e.on("message",async e=>{if(e)if(e.event)try{await handleResponse(e,t,n,!0,s,a),r("succeed")}catch(e){o(e)}else if(e.type!==build_event_js_1.WatchEvent.WATCH_COMPILE_RESULT&&e.type!==build_event_js_1.WatchEvent.WATCH_START&&e.type!==build_event_js_1.WatchEvent.WATCH_RESULT&&e.type!==build_event_js_1.WatchEvent.WATCH_LOG){if(e.type===build_event_js_1.WatchEvent.TERMINATE_WORKER)return log.debug("watch worker: worker is ready to be terminated."),void this.terminateWorker(e.content);o(new Error(`Unknown watch event: ${e}.`))}else{log.debug(`watch worker: send response to session manager. Response type: ${e.type}`);try{await hvigor_lifecycle_hook_js_1.HvigorLifecycleHook.getInstance().runHook(hook_const_js_1.HookType.onWatchWorkerMessage,e,a)}catch(e){log.error(`custom onWatchWorkerMessage hook exception: ${e.message}`)}cluster_1.default.isWorker&&("hotCompile"===e.hotCompile?process.send({type:`${!0===e.content?worker_process_event_id_js_1.WORKER_PROCESS_EVENT_ID.FINISHED:worker_process_event_id_js_1.WORKER_PROCESS_EVENT_ID.FAILED}`}):process.send({...e,workerId:n}))}else o(new Error("Undefined response."))})}createWorkerOnErrorListener(e,r,o,t){e.on("error",async e=>{log.error(`${o.getName()} watch work[${t}] failed.`),log.error(e),r(e)})}beforeTerminate(e){var r,o;(null===(r=this.workerMap.get(e))||void 0===r?void 0:r.hasCustomTerminate)?null===(o=this.workerMap.get(e))||void 0===o||o.worker.postMessage({type:build_event_js_1.WatchEvent.TERMINATE_WORKER,content:e}):this.terminateWorker(e)}terminateWorker(e){var r;null===(r=this.workerMap.get(e))||void 0===r||r.worker.terminate(),this.workerMap.delete(e),log.debug(`Server currently has ${this.workerMap.size} ${this.workerMap.size>1?"watch-workers":"watch-worker"}`)}addListenersOnSessionManager(){cluster_1.default.isWorker&&cluster_1.default.worker.on("message",e=>{var r;void 0!==e.workerId&&0!==e.workerId?e.type===build_event_js_1.WatchEvent.WATCH_COMPILE_DATA?(log.debug("watch worker: receive watch compile tata."),null===(r=this.getWorker(e.workerId))||void 0===r||r.postMessage(e.content)):e.type===build_event_js_1.WatchEvent.CLOSE_WATCH&&this.beforeTerminate(e.workerId):log.debug("watch worker: worker id should be larger than 0. Nothing will be sent to any worker thread.")})}}class NormalWorker{constructor(){this.maxWorkerNum=constant_js_1.PoolConstant.MAX_POOL_NUM>1?constant_js_1.PoolConstant.MAX_POOL_NUM-1:1}createWorker(e,r,o,t,n){const s=Number(process.hrtime.bigint()),a=WorkerCountManager.allocateWorkerId(),{promise:i,resolve:l,reject:_}=genPromiseAndTriggers(e,s);return e.pendingPromises.add(i),NormalWorker.promiseMap.set(a,{resolve:l,reject:_}),NormalWorker.runningThreadCnt>=this.maxWorkerNum?(log.debug(`Creating worker failed since runningThreadCnt is not smaller than ${this.maxWorkerNum}.`),NormalWorker.workQueue.push({workerId:a,task:e,filename:r,callback:t,options:n})):(log.debug(`Creating worker with id ${a}.`),this.executeWorker(a,e,r,t,n)),a.toString()}reset(){NormalWorker.runningThreadCnt=0,NormalWorker.workQueue.length=0,NormalWorker.promiseMap.clear()}executeWorker(e,r,o,t,n){const s=new worker_threads_1.Worker(o,n);NormalWorker.runningThreadCnt++;const{resolve:a,reject:i}=NormalWorker.promiseMap.get(e);NormalWorker.promiseMap.delete(e);const l=r.addSubDurationEvent(e.toString()).start();null==l||l.setTid(`Worker${e}`),s.on("message",async o=>{if(o)if(o.event)try{if(await handleResponse(o,r,e,!1,t,l),s.terminate(),NormalWorker.runningThreadCnt--,NormalWorker.workQueue.length){const e=NormalWorker.workQueue.shift();log.debug(`Normal worker queue is not empty. Create worker with id: ${e.workerId}.`),this.executeWorker(e.workerId,e.task,e.filename,e.callback,e.options)}a(!0)}catch(e){i(e)}else o.type!==build_event_js_1.WatchEvent.WATCH_COMPILE_RESULT&&o.type!==build_event_js_1.WatchEvent.WATCH_START&&o.type!==build_event_js_1.WatchEvent.WATCH_RESULT&&o.type!==build_event_js_1.WatchEvent.WATCH_LOG&&(o.type!==build_event_js_1.WatchEvent.TERMINATE_WORKER?i(new Error(`Unknown watch event: ${o}.`)):log.debug("Impossible response type in normal worker: TERMINATE_WORKER"));else i(new Error("Undefined response."))}),s.on("error",async o=>{log.debug(`${r.getName()} normal work[${e}] failed.`),i(o)})}}NormalWorker.runningThreadCnt=0,NormalWorker.workQueue=[],NormalWorker.promiseMap=new Map,exports.watchWorker=new WatchWorker,exports.normalWorker=new NormalWorker;