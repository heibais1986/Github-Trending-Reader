"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,s,a){void 0===a&&(a=s);var i=Object.getOwnPropertyDescriptor(t,s);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[s]}}),Object.defineProperty(e,a,i)}:function(e,t,s,a){void 0===a&&(a=s),e[a]=t[s]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var s in e)"default"!==s&&Object.prototype.hasOwnProperty.call(e,s)&&__createBinding(t,e,s);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.TaskProxy=void 0;const fs=__importStar(require("fs")),const_js_1=require("../../../../common/const/const.js"),hvigor_core_js_1=require("../../../external/core/hvigor-core.js"),incremental_exec_task_js_1=require("../../../external/task/incremental-exec-task.js"),hvigor_log_js_1=require("../../../log/hvigor-log.js"),time_util_js_1=require("../../../util/time-util.js"),project_cache_service_js_1=require("../../cache/project-cache-service.js"),cache_util_js_1=require("../../cache/util/cache-util.js"),snapshot_comparator_service_js_1=require("../../snapshot/service/snapshot-comparator-service.js"),snapshot_generator_service_js_1=require("../../snapshot/service/snapshot-generator-service.js"),_log=hvigor_log_js_1.HvigorLogger.getLogger("hvigor-task-proxy");function withCache(e){let t=null,s=!1;return function(...a){return s||(t=e.apply(this,...a),s=!0),t}}class TaskProxy{constructor(e){var t;this.notDeclareAnyIncrementalLogic=!1,this.useInputOutputCache=!1,this.task=e,this.taskNode=e.getNode(),this.project=this.taskNode.getProject(),this.projectCacheService=project_cache_service_js_1.ProjectCacheService.getInstance(this.project),this.useInputOutputCache=null!==(t=hvigor_core_js_1.hvigorCore.getParameter().getProperty(const_js_1.INCREMENTAL_INPUT_OUTPUT_CACHE))&&void 0!==t&&t,this.useInputOutputCache&&(this.task.declareInputs=withCache(this.task.declareInputs),this.task.declareInputFiles=withCache(this.task.declareInputFiles),this.task.declareOutputFiles=withCache(this.task.declareOutputFiles)),this.snapshotGeneratorService=snapshot_generator_service_js_1.SnapshotGeneratorService.getInstance(),this.snapshotComparatorService=snapshot_comparator_service_js_1.SnapshotComparatorService.getInstance(),this.cacheTaskSnapShot=this.projectCacheService.getTaskSnapShot(e.getName(),this.taskNode),this.curInputFileSnapShotMap=new Map,this.useInputOutputCache&&(this.notDeclareAnyIncrementalLogic=0===this.task.declareInputs().size&&0===this.task.declareInputFiles().collect().size&&0===this.task.declareOutputFiles().collect().size,this.notDeclareAnyIncrementalLogic&&e instanceof incremental_exec_task_js_1.IncrementalExecTask&&(this.notDeclareAnyIncrementalLogic=""===e.declareExecutionTool()&&""===e.declareExecutionCommand()&&0===e.declareExecutionEnv().size))}isTaskChange(){return this.curTaskSnapShot.updateCacheFilesOptions(this.projectCacheService),void 0!==this.cacheTaskSnapShot&&this.cacheTaskSnapShot.isSuccessful()?!!snapshot_comparator_service_js_1.SnapshotComparatorService.isDiff(this.cacheTaskSnapShot,this.curTaskSnapShot)&&(_log.debug(`${this.task.getPath()} is not up-to-date, since the task snapshots are different.`),this.task.durationEvent.addTaskRunReason("The task snapshots are different."),!0):(_log.debug(`${this.task.getPath()} is not up-to-date, since no history record is available.`),this.task.durationEvent.addTaskRunReason("No history record is available."),!0)}getFileCompareResult(e,t){const s=this.snapshotGeneratorService.generateFileSystemSnapshot(e,t),a=this.projectCacheService.getFileSnapShot(e);return a?[s,snapshot_comparator_service_js_1.SnapshotComparatorService.isDiff(a,s)]:[s,!0]}isTaskInputFilesChange(){var e;const t=this.task.declareInputFiles().collect();for(const[s,a]of t){if(!fs.existsSync(s))throw new Error(`Failed to find the incremental input file: ${s}.`);const t=this.getFileCompareResult(s,a);if(t[1])return null===(e=this.curInputFileSnapShotMap)||void 0===e||e.set(s,t[0]),_log.debug(`${this.task.getPath()} is not up-to-date, since the input file '${s}' has been changed.`),this.task.durationEvent.addTaskRunReason(`The input file '${s}' has been changed.`),!0}return!1}isTaskOutputFilesChange(){const e=this.task.declareOutputFiles().collect();for(const[t,s]of e){if(!fs.existsSync(t))return _log.debug(`${this.task.getPath()} is not up-to-date, since the output file '${t}' does not exist.`),this.task.durationEvent.addTaskRunReason(`The output file '${t}' does not exist.`),!0;if(this.getFileCompareResult(t,s)[1])return _log.debug(`${this.task.getPath()} is not up-to-date, since the output file '${t}' has been changed.`),this.task.durationEvent.addTaskRunReason(`The output file '${t}' has been changed.`),!0}return!1}preExecute(){var e;const t=process.hrtime();if(this.useInputOutputCache&&this.notDeclareAnyIncrementalLogic){const e=process.hrtime(t),s=(0,time_util_js_1.formatTime)(e);return _log.debug(`${this.task.getPath()} is declared as IncrementTask, but does not implement any incremental method.`),_log.debug(`Incremental task ${this.task.getPath()} pre-execution cost: ${s}.`),!1}if(this.curTaskSnapShot=this.snapshotGeneratorService.generateTaskSnapshot(this.task),!(null===(e=this.cacheTaskSnapShot)||void 0===e?void 0:e.isSuccessful()))return!1;const s=this.isTaskInputFilesChange();if(s){const e=process.hrtime(t),s=(0,time_util_js_1.formatTime)(e);return _log.debug(`Incremental task ${this.task.getPath()} pre-execution cost: ${s}.`),!1}const a=this.isTaskOutputFilesChange();if(a){const e=process.hrtime(t),s=(0,time_util_js_1.formatTime)(e);return _log.debug(`Incremental task ${this.task.getPath()} pre-execution cost: ${s}.`),!1}const i=!this.isTaskChange()&&!s&&!a,r=process.hrtime(t),o=(0,time_util_js_1.formatTime)(r);return _log.debug(`Incremental task ${this.task.getPath()} pre-execution cost: ${o}.`),i}async execute(){await this.task.execute()}postExecute(){const e=process.hrtime();if(this.task.taskExecutedStatus.isUpToDate())return void _log.debug(`There is no need to refresh cache, since the incremental task ${this.task.getPath()} is up-to-date.`);this.updateTaskInputFilesSnapshot(),this.updateTaskOutputFilesSnapShot(),this.updateTaskSnapShot();const t=process.hrtime(e),s=(0,time_util_js_1.formatTime)(t);_log.debug(`Incremental task ${this.task.getPath()} post-execution cost:${s}.`)}updateTaskOutputFilesSnapShot(){this.task.declareOutputFiles().collect().forEach((e,t)=>{_log.debug(`Update task ${this.task.getPath()} output file:${t} cache.`);const s=this.snapshotGeneratorService.generateFileSystemSnapshot(t,e);this.projectCacheService.updateFileSnapShot(t,s)})}updateTaskInputFilesSnapshot(){this.task.declareInputFiles().collect().forEach((e,t)=>{if(this.curInputFileSnapShotMap.has(t))_log.debug(`Update task ${this.task.getPath()} input file:${t} cache from map.`),this.projectCacheService.updateFileSnapShot(t,this.curInputFileSnapShotMap.get(t));else{_log.debug(`Update task ${this.task.getPath()} input file:${t} cache by regenerate.`);const s=this.snapshotGeneratorService.generateFileSystemSnapshot(t,e);this.projectCacheService.updateFileSnapShot(t,s)}})}updateTaskSnapShot(){const e=(0,cache_util_js_1.getTaskSnapCacheEntryUniqueKey)(this.task.getName(),this.taskNode);this.curTaskSnapShot||(this.curTaskSnapShot=this.snapshotGeneratorService.generateTaskSnapshot(this.task)),this.curTaskSnapShot.updateFilesOptions(this.projectCacheService),this.projectCacheService.updateTaskSnapShot(e,this.curTaskSnapShot)}getCurTaskSnapShot(){return this.curTaskSnapShot}}exports.TaskProxy=TaskProxy;